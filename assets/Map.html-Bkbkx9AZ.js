import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,b as l,o as h}from"./app-2PeO27O1.js";const e="/blog/assets/Map-D5C5E9qy.png",n={};function p(t,s){return h(),i("div",null,s[0]||(s[0]=[l('<h1 id="基础简介" tabindex="-1"><a class="header-anchor" href="#基础简介"><span>基础简介</span></a></h1><figure><img src="'+e+`" alt="Map" tabindex="0" loading="lazy"><figcaption>Map</figcaption></figure><h2 id="map实现类细节" tabindex="-1"><a class="header-anchor" href="#map实现类细节"><span>Map实现类细节</span></a></h2><ul><li>Map：双列数据，存储key-value对的数据 <ul><li>HashMap：作为Map的主要实现类；线程不安全的，效率高；存储null的key和value<br><code>JDK7底层：数组+链表</code><br><code>JDK8底层：数组+链表+红黑树</code><ul><li>LinkedHashMap：保证在遍历map元素时，可以按照添加的顺序实现遍历。<br><code>原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</code><br><code>对于频繁的遍历操作，此类执行效率高于HashMap。</code></li></ul></li><li>TreeMap：保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序。<br><code>底层使用红黑树</code></li><li>Hashtable：作为古老的实现类；线程安全的，效率低；不能存储null的key和value。 <ul><li>Properties：常用来处理配置文件。key和value都是String类型。</li></ul></li></ul></li></ul><h2 id="map结构理解" tabindex="-1"><a class="header-anchor" href="#map结构理解"><span>Map结构理解</span></a></h2><p><strong>Map中的key</strong>：</p><ul><li>无序的、不可重复的，使用Set存储所有的key &gt;&gt;&gt; 所在的类要重写equals()和hashCode() （以HashMap为例）</li></ul><p><strong>Map中的value</strong>：</p><ul><li>无序的、可重复的，使用Collection存储所有的value &gt;&gt;&gt; value所在的类要重写equals()</li></ul><p><code>一个键值对：key-value构成了一个Entry对象。</code><br><code>Map中的entry：无序的、不可重复的，使用Set存储所有的entry</code></p><h2 id="hashmap源码常量" tabindex="-1"><a class="header-anchor" href="#hashmap源码常量"><span>HashMap源码常量</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>DEFAULT_INITIAL_CAPACITY：16 &gt; HashMap的默认容量<br> DEFAULT_LOAD_FACTOR：0.75 &gt; HashMap的默认加载因子<br> threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12<br> TREEIFY_THRESHOLD：8 &gt; Bucket中链表长度大于该默认值，转化为红黑树<br> MIN_TREEIFY_CAPACITY：64 &gt; 桶中的Node被树化时最小的hash表容量</p></div><h2 id="hashmap底层原理" tabindex="-1"><a class="header-anchor" href="#hashmap底层原理"><span>HashMap底层原理</span></a></h2><p>HashMap map = new HashMap()<br> 在实例化以后，底层创建了长度是16的一维数组Entry[] table。</p><p><strong>JDK7</strong>：map.put(key1,value1)</p><ul><li>首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</li><li>如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1</li><li>如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值： <ul><li>如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2</li><li>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较： <ul><li>如果equals()返回false:此时key1-value1添加成功。----情况3</li><li>如果equals()返回true:使用value1替换value2。</li></ul></li></ul></li></ul><p><code>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</code></p><p><strong>JDK8</strong>：相较于jdk7在底层实现方面的不同：</p><ul><li>new HashMap():底层没有创建一个长度为16的数组</li><li>jdk 8底层的数组是：Node[],而非Entry[]</li><li>首次调用put()方法时，底层创建长度为16的数组</li><li>jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。 <ul><li>形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</li><li>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</li></ul></li></ul><h2 id="hashmap的hash-方法实现" tabindex="-1"><a class="header-anchor" href="#hashmap的hash-方法实现"><span>HashMap的hash()方法实现</span></a></h2><p><strong>hashCode() 的高 16 位异或低 16 位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</strong><br> 主要是从速度，功效和质量来考虑的，减少系统的开销，也不会造成因为高位没有参与下标的计算，从而引起的碰撞。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> V</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> put</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">K</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> V</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> value) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> putVal</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hash</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(key)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> final</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> hash</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> key) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> h</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (key </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">?</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> :</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (h </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">hashCode</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">) </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">^</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (h </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;&gt;&gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 16</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="hashmap扩容" tabindex="-1"><a class="header-anchor" href="#hashmap扩容"><span>HashMap扩容</span></a></h2><p>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p><p>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size) x loadFactor时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数超过16 x 0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为2x16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p><h2 id="hashmap-put-方法的逻辑" tabindex="-1"><a class="header-anchor" href="#hashmap-put-方法的逻辑"><span>HashMap put()方法的逻辑</span></a></h2><p>1.首先判断当前哈希表是否已经被初始化，没有的话使用resize（）方法初始化，创建一个长度为16的数组<br> 2.判断当前位置有无节点，没有的话直接新new一个节点放入<br> 3.当前位置有节点需要判断key是否相同，相同的话需要新值覆盖旧值<br> 4.不相同的话判断当前节点是否是红黑树节点，是的话按照红黑树的插入方法插入<br> 5.不是的话进行链表的遍历，查看是否有key相同的节点，有的话新值覆盖旧值，没有的话正常来说走到最后一个节点，使用尾插法插入即可</p><h2 id="hashmap-get-方法的逻辑" tabindex="-1"><a class="header-anchor" href="#hashmap-get-方法的逻辑"><span>HashMap get()方法的逻辑</span></a></h2><p>1.调用hash(K)方法（计算K的hash 值)从而获取该键值所在链表的数组下标<br> 2.判断下标对应的数组是否为空 空格就直接返回null；不为空，比较hash值，hash值相同之后才比较key是否相同，如果key相同，则返回该对象<br> 3.如果不相同就往下个节点寻找，下个节点是红黑树的话直接通过红黑树遍历寻找，不是红黑树直接遍历链表</p><h2 id="什么是hash冲突" tabindex="-1"><a class="header-anchor" href="#什么是hash冲突"><span>什么是hash冲突？</span></a></h2><p>所谓hash冲突，是由于哈希算法被计算的数据是无限的，而计算后的结果范围有限，所以总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突。</p><h2 id="map如何按照插入顺序排序-访问顺序排序-自然顺序排序-自定义排序" tabindex="-1"><a class="header-anchor" href="#map如何按照插入顺序排序-访问顺序排序-自然顺序排序-自定义排序"><span>Map如何按照插入顺序排序？访问顺序排序？自然顺序排序？自定义排序？</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">自然顺序排序： </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">TreeMap</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">   </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">自定义排序：利用 TreeMap 自带的可以传递一个 Comparator比较器的构造函数 或者 使用 工具类 </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">Collections</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * accessOrder true 访问顺序排序 false 插入顺序排序  默认是false</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> LinkedHashMap</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> initialCapacity</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> float</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> loadFactor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> accessOrder) {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  super</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(initialCapacity</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> loadFactor)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">accessOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> accessOrder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="concurrenthashmap-put-方法" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-put-方法"><span>ConcurrentHashMap put()方法</span></a></h2><ul><li>如果没有初始化，就调用 initTable() 方法来进行初始化；</li><li>如果没有 hash 冲突就直接 CAS 无锁插入；</li><li>如果需要扩容，就先进行扩容；</li><li>如果存在 hash 冲突，就加锁来保证线程安全，两种情况：一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入；</li><li>如果该链表的数量大于阀值 8，就要先转换成红黑树的结构，break 再一次进入循</li><li>如果添加成功就调用 addCount() 方法统计 size，并且检查是否需要扩容。</li></ul>`,35)]))}const d=a(n,[["render",p],["__file","Map.html.vue"]]),c=JSON.parse('{"path":"/Java/base/Map.html","title":"Map","lang":"zh-CN","frontmatter":{"title":"Map","icon":"java","category":"JavaSE","date":"2022-06-14T00:00:00.000Z","tag":["Java","Map"]},"headers":[{"level":2,"title":"Map实现类细节","slug":"map实现类细节","link":"#map实现类细节","children":[]},{"level":2,"title":"Map结构理解","slug":"map结构理解","link":"#map结构理解","children":[]},{"level":2,"title":"HashMap源码常量","slug":"hashmap源码常量","link":"#hashmap源码常量","children":[]},{"level":2,"title":"HashMap底层原理","slug":"hashmap底层原理","link":"#hashmap底层原理","children":[]},{"level":2,"title":"HashMap的hash()方法实现","slug":"hashmap的hash-方法实现","link":"#hashmap的hash-方法实现","children":[]},{"level":2,"title":"HashMap扩容","slug":"hashmap扩容","link":"#hashmap扩容","children":[]},{"level":2,"title":"HashMap put()方法的逻辑","slug":"hashmap-put-方法的逻辑","link":"#hashmap-put-方法的逻辑","children":[]},{"level":2,"title":"HashMap get()方法的逻辑","slug":"hashmap-get-方法的逻辑","link":"#hashmap-get-方法的逻辑","children":[]},{"level":2,"title":"什么是hash冲突？","slug":"什么是hash冲突","link":"#什么是hash冲突","children":[]},{"level":2,"title":"Map如何按照插入顺序排序？访问顺序排序？自然顺序排序？自定义排序？","slug":"map如何按照插入顺序排序-访问顺序排序-自然顺序排序-自定义排序","link":"#map如何按照插入顺序排序-访问顺序排序-自然顺序排序-自定义排序","children":[]},{"level":2,"title":"ConcurrentHashMap put()方法","slug":"concurrenthashmap-put-方法","link":"#concurrenthashmap-put-方法","children":[]}],"git":{"createdTime":1733323129000,"updatedTime":1733323129000,"contributors":[{"name":"CodingQ92","email":"codingrepo@163.com","commits":1}]},"readingTime":{"minutes":6.65,"words":1994},"filePathRelative":"Java/base/Map.md","localizedDate":"2022年6月14日","excerpt":"\\n<figure><figcaption>Map</figcaption></figure>\\n<h2>Map实现类细节</h2>\\n<ul>\\n<li>Map：双列数据，存储key-value对的数据\\n<ul>\\n<li>HashMap：作为Map的主要实现类；线程不安全的，效率高；存储null的key和value<br>\\n<code>JDK7底层：数组+链表</code><br>\\n<code>JDK8底层：数组+链表+红黑树</code>\\n<ul>\\n<li>LinkedHashMap：保证在遍历map元素时，可以按照添加的顺序实现遍历。<br>\\n<code>原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</code><br>\\n<code>对于频繁的遍历操作，此类执行效率高于HashMap。</code></li>\\n</ul>\\n</li>\\n<li>TreeMap：保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序。<br>\\n<code>底层使用红黑树</code></li>\\n<li>Hashtable：作为古老的实现类；线程安全的，效率低；不能存储null的key和value。\\n<ul>\\n<li>Properties：常用来处理配置文件。key和value都是String类型。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>"}');export{d as comp,c as data};
