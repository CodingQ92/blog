import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as k,b as h,a,d as s,e as l,f as t,r as p,o as d}from"./app-2PeO27O1.js";const r={},A={class:"hint-container tip"};function g(y,i){const n=p("font");return d(),k("div",null,[i[23]||(i[23]=h(`<h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h2><table><thead><tr><th>类型</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>0</td></tr><tr><td>short</td><td>2</td><td>0</td></tr><tr><td>int</td><td>4</td><td>0</td></tr><tr><td>long</td><td>8</td><td>0L</td></tr><tr><td>float</td><td>4</td><td>0.0f</td></tr><tr><td>double</td><td>8</td><td>0.0d</td></tr><tr><td>char</td><td>2</td><td>\\u0000</td></tr><tr><td>boolean</td><td>1</td><td>false</td></tr></tbody></table><p>int 面试题</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> IntegerTest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> f1</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, f2 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 100</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, f3 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 140</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, f4 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 140</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(f1 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> f2);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(f3 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> f4);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,4)),a("div",A,[i[5]||(i[5]=a("p",{class:"hint-container-title"},"提示",-1)),a("p",null,[i[1]||(i[1]=s("当 int 数据类型 数值范围是")),l(n,{color:"orange"},{default:t(()=>i[0]||(i[0]=[s(" -128-127 ")])),_:1}),i[2]||(i[2]=s("之间，integer是不会创建新的变量会直接用已经缓存的，超过此范围才会使用新的。")),i[3]||(i[3]=a("br",null,null,-1)),i[4]||(i[4]=s(" 所以上面的 f1 == f2 true f3 == f4 false"))])]),i[24]||(i[24]=h('<h2 id="面向对象" tabindex="-1"><a class="header-anchor" href="#面向对象"><span>面向对象</span></a></h2><p><code>方法重载</code>满足条件：</p><ul><li>方法名必须相同 <code>必要条件</code></li><li>参数列表不同（参数个数、类型、参数排列顺序）<code>必要条件</code></li><li>方法返回类型可以相同也可以不相同</li><li>重载发生在编译时，因为编译器可以根据参数的类型来选择使用哪个方法</li></ul><p><code>方法重写</code>满足条件：</p><ul><li>必须存在子父类继承关系 <code>必要条件</code></li><li>重写的方法必须要和父类保持一致，包括<strong>返回值类型、方法名、参数列表</strong>也都是一样</li><li>子类中重写方法的访问权限不能低于分类中方法的访问权限</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>构造器（constructor）是否可被重写（override）?<br> 答：构造器不能被继承，因此不能被重写，但可以被重载。</p></div><p><code>初始化顺序</code>：</p><ul><li>静态属性初始化</li><li>静态方法块初始化</li><li>普通属性初始化</li><li>普通方法块初始化</li><li>构造函数初始化</li></ul><p><code>this 和 super</code>：<br><strong>this</strong>：表示当前对象，this可以调用方法、属性和<em>指向对象本身</em>。<br><strong>super</strong>：表示父类对象，super可以调用父类的方法、属性。</p><p><code>继承</code>：继承是所有oop语言和Java语言不可或缺的一部分。只要我们创建了一个类它就默认继承自<strong>Object</strong>父类。如果你指定了其他的父类，那就是你指定的父类继承自<strong>Object</strong>。 继承关键字：<strong>extends</strong></p><p><code>多态</code>：多态是指同一个行为具有多个不同的表现形式。是指一个实例（对象）的相同方法在不同情形下具有不同表现形式。封装和继承是多态的基础。<br><strong>多态满足条件：</strong></p><ul><li>继承</li><li>重写父类方法</li><li>父类引用指向子类对象</li></ul><p>向上转型：通过子类对象转化为父类对象，自动完成，不用强制。<br> 向下转型：通过父类对象转化为子类对象，不是自定完成，需要强制转换。</p><p><code>组合</code>：多用组合，少用继承</p><p><strong>组合和继承区别</strong></p><table><thead><tr><th>特征</th><th>组合</th><th>继承</th></tr></thead><tbody><tr><td>关系</td><td>组合是has-a关系，可以理解为有一个</td><td>继承是is-a关系，可以理解为是一个</td></tr><tr><td>耦合性</td><td>组合双方是一种松耦合关系</td><td>继承双方是紧耦合</td></tr><tr><td>是否具有多态</td><td>否</td><td>是</td></tr><tr><td>时期</td><td>组合是运行期绑定</td><td>继承是编译期绑定</td></tr></tbody></table><p><code>static</code>：Java中的关键字，意思是静态的，可以修饰成员变量和方法，被修饰的方法和变量可以直接在没有创建对象的时候用<strong>类名.属性/方法</strong>访问</p><p><code>final</code>：可以修饰类、属性、方法</p><ul><li>final修饰类时，类不可被继承。final类中成员变量可以根据需要设置为final，但是要注意所有成员方法会被隐式的指定为final方法。</li><li>final修饰方法时，表示此方法不可被任何子类重写</li><li>final修饰变量有俩种情况：修饰基本数据类型，表示数值不可修改；修饰引用数据类型，表示对象初始化后不能再指向其他的对象。</li></ul><h2 id="接口和抽象类" tabindex="-1"><a class="header-anchor" href="#接口和抽象类"><span>接口和抽象类</span></a></h2><p><code>接口特征</code></p>',21)),a("ul",null,[i[16]||(i[16]=a("li",null,"一个完全抽象的类，不会有任何方法的实现，只可以定义。",-1)),a("li",null,[i[8]||(i[8]=s("接口中只有俩种访问修饰符，一种是")),l(n,{color:"orange"},{default:t(()=>i[6]||(i[6]=[s("public")])),_:1}),i[9]||(i[9]=s("，对整个项目可见，一种是")),l(n,{color:"orange"},{default:t(()=>i[7]||(i[7]=[s("default")])),_:1}),i[10]||(i[10]=s("缺省，具有包访问权限。"))]),a("li",null,[i[12]||(i[12]=s("接口只提供方法的定义，接口没有实现，但是可以被其他的类用关键字")),l(n,{color:"orange"},{default:t(()=>i[11]||(i[11]=[s("implements")])),_:1}),i[13]||(i[13]=s("实现。"))]),i[17]||(i[17]=a("li",null,"接口不能被实例化，不可以有构造方法。",-1)),a("li",null,[i[15]||(i[15]=s("接口必须实现接口的所有方法，否则必须定义为")),l(n,{color:"orange"},{default:t(()=>i[14]||(i[14]=[s("抽象类")])),_:1})])]),i[25]||(i[25]=a("div",{class:"hint-container tip"},[a("p",{class:"hint-container-title"},"提示"),a("p",null,[s("注：JDK 1.8 以后，接口里可以有静态方法和方法体了。"),a("br"),s(' 注：JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为"默认方法"，默认方法使用 default 关键字修饰。更多内容可参考 Java 8 默认方法。'),a("br"),s(" 注：JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。更多内容可参考 Java 9 私有接口方法。")])],-1)),a("p",null,[i[19]||(i[19]=a("code",null,"抽象类",-1)),i[20]||(i[20]=s("：抽象类是一种抽象能力弱于接口的类，在Java中，抽象类使用")),l(n,{color:"orange"},{default:t(()=>i[18]||(i[18]=[s("abstract")])),_:1}),i[21]||(i[21]=s("关键字来表示。如果把接口形容为狗这个物种，那么抽象类可以说是毛发是白色、小体的品种，而实现类可以是具体的类，比如说是博美、泰迪等。你可以像下面这样定义抽象类 ")),i[22]||(i[22]=a("strong",null,"特征",-1))]),i[26]||(i[26]=h(`<ul><li>如果一个类中有抽象方法，那么这个类一定是抽象类。</li><li>抽象类不一定有抽象方法，抽象类也可以有普通方法。</li><li>抽象类中可以定义<strong>构造方法、抽象方法、普通方法、方法、静态属性和静态方法</strong>。</li><li>抽象类和接口一样不能被实例化，实例化只能实例化具体的类。</li></ul><h2 id="谈谈你对java的理解" tabindex="-1"><a class="header-anchor" href="#谈谈你对java的理解"><span>谈谈你对Java的理解</span></a></h2><ul><li>首先是一种面向对象的语言，语言特性有封装，继承，多态</li><li>支持跨平台，一次书写到处运行</li><li>垃圾回收器(GC)，程序员不用关注内存的分配和回收</li></ul><h2 id="和-equals的区别" tabindex="-1"><a class="header-anchor" href="#和-equals的区别"><span>== 和 equals的区别</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>== 运算符</p><ul><li>可以使用在基本数据类型变量和引用数据类型变量中</li><li>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。(不一定类型要相同)</li><li>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同,即两个引用是否指向同一个对象实体<br><code>== 符号使用时，必须保证符号左右两边的变量类型一致。</code></li></ul><p>equals()方法的使用</p><ul><li>是一个方法，而非运算符</li><li>只能适用于引用数据类型。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // Object类中equals()的定义：</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> equals</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Object</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> obj) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> obj)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Object类中定义的equals()和==的作用是相同的，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体。</code></p><ul><li><p>像String、Date、File、包装类等都重写了Object类中的equals()方法.<br> 两个引用的地址是否相同，而是比较两个对象的“实体内容”是否相同。</p></li><li><p>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的&quot;实体内容&quot;是否相同。<br> 那么，我们就需要对Object类中的equals()进行重写。</p></li></ul><p><code>重写的原则:比较两个对象的实体内容是否相同。</code></p></div><h2 id="a-a-b-与-a-b-的区别" tabindex="-1"><a class="header-anchor" href="#a-a-b-与-a-b-的区别"><span>a = a + b 与 a += b 的区别</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是a += b 没问题</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 127</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">byte</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> b </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 127</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> b </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // error : cannot convert from int to byte</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">b </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// ok</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><h2 id="自增变量面试题解析" tabindex="-1"><a class="header-anchor" href="#自增变量面试题解析"><span>自增变量面试题解析</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[] args) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 局部变了表 i=1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 把i压入操作数栈 局部变量表 i=1 操作数栈 1</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 执行i++ i自增 局部变量表i=2 操作数栈 1</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 执行=赋值操作 将 操作数栈 1 转移到 局部变量表 i  i 就被 覆盖成 i=1</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 结果：i=1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 把i压入操作数栈 操作数栈 1</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 执行i++ 局部变量表i自增 i=2 操作数栈 1</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 执行=赋值操作 将 操作数栈 1 转移到 局部变量表 j 所以j=1 i没有被覆盖 局部变量表 i=2</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 结果：i=2 j=1</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++;</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 把i压入操作数栈 局部变量表 i=2 j=1 k=0 操作数栈 2</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 执行++i （先自增后入栈 所以目前栈顶部是 3） 局部变量表 i=3 j=1 k=0 操作数栈  3 2 俩个数值 （2在下面）</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 执行i++ （先入栈后自增 所以目前栈顶部还是 3） 局部变量表 i=4 j=1 k=0 操作数栈  3 3 2 三个数值 （2在下面）</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 计算乘法 （3*3算后因为没办法赋值给指定变量 所以又入栈了）局部变量表 i=4 j=1 k=0 操作数栈  9（3*3） 2 俩个数值 （2在下面）</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 计算加法  局部变量表 i=4 j=1 k=0 操作数栈  11（9+2） 一个数值</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 执行=赋值操作 操作数栈 11 赋值给 k 最终 局部变量表 i=4 j=1 k=11</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> k </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">i </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">++;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;i=&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 4</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;j=&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> j);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 1</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">  System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;k=&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> k);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 11</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>++ 操作符不需要在操作数栈计算 是直接在局部变量表执行</p><ul><li>++在前 先自增后入操作数栈</li><li>++在后 先入操作数栈后自增</li></ul></div><h2 id="当一个对象被当做参数传递给一个方法-此方法可以改变这个对象的属性-并返回变化后的结果-那么这里到底是值传递还是引用传递" tabindex="-1"><a class="header-anchor" href="#当一个对象被当做参数传递给一个方法-此方法可以改变这个对象的属性-并返回变化后的结果-那么这里到底是值传递还是引用传递"><span>当一个对象被当做参数传递给一个方法，此方法可以改变这个对象的属性，并返回变化后的结果，那么这里到底是值传递还是引用传递？</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>值传递。<br> Java没有引用传递，都是值传递。<br> 只不过引用类型传的是地址值，基本类型是数值。<br> 如果参数是基本数据类型，此时实参赋值给形参的是实参真实存储的数据值。<br> 如果参数是引用数据类型，此时实参赋值给形参的是实参存储数据的地址值。</p></div><h2 id="值传递和引用传递面试题" tabindex="-1"><a class="header-anchor" href="#值传递和引用传递面试题"><span>值传递和引用传递面试题</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 具体的内存流程解析：</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 1.main方法进栈</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 1.1局部变量表声明i基本数据类型 并 赋值 1</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 1.2局部变量表声明str对象 指向堆内存中的 字符串常量池的指定地址 jdk1.7</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 1.3局部变量表声明num对象 （范围不在-128-127之间，不用缓存）直接在堆中开辟对象存储</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 1.4局部变量表声明arr对象 堆中开辟空间存储一个长度4位的数组对象并给对于的每个下标赋值</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 1.5局部变量表声明MyData对象 堆中开辟空间存储对象 并且有个属性i=10</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 2.change方法进栈（main方法在栈底 change在其上）</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 2.1将i的值传递给j j=1；</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> *    str的地址值传递给s s和str共同指向堆内存常量池的 hello；</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> *    num的地址值传递给n n和num共同指向堆内存200的地址；</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> *    arr的地址值传递给a a和arr共同指向{1, 2, 3, 4}堆内存地址</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> *    myData的地址值传递给md md和myData共同指向myData堆内存地址</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 2.2 j += 1;----&gt; change栈帧中的j改为2</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 2.3 s += &quot;world&quot;;----&gt; String是特殊的引用类型</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> *     先在堆中的常量池查找world 没有就新建 然后再拼接后找hello world 没有新建返回新的地址值给s</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> *     原本s=hello时和main方法的str共同指向对空间字符串常量池的hello地址</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> *     此时因为拼接了world形成新的对象引用，s地址值和str就不一样了 str并没有改变</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 2.4 n += 1;----&gt; 包装类是特殊的引用类型和String一样不可变 改变其值只能在堆新开辟一个新的</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> *     所以change栈中的n和main栈中的num又不是一个堆中的地址值 main中的num地址不变</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 2.5 a[0] += 1; md.a = 1; ----&gt; 此俩步都是对象的引用 改变的是对象中的某个属性 并未改变地址</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> *     此时change和main地址值都一样 但内部的属性都已变</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 2.6 md.a = 1; 执行完了就弹栈了 此时  int j, String s, Integer n, int[] a, MyData md 都消失了</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * 最终结果 1 hello 200 {2, 2, 3, 4} 1</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> **/</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ValuePassedTest</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> str</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> num</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">arr</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    MyData</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> myData</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MyData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 改变值</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    change</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i, str, num, arr, myData);</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;i=&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 1</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;str=&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> str); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// hello</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;num=&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> num); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 2</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;arr=&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> Arrays</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">toString</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(arr)); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// [2, 2, 3, 4]</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;myData.a=&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> myData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> change</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> j</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">MyData</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> md</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> j </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    s </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;world&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> n </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    a[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">    md</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyData</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> a </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><ul><li>String 和 包装类 不可变性</li><li>值传递和引用传递<br><code>如果参数是基本数据类型，此时实参赋值给形参的是实参真实存储的数据值。</code><br><code>如果参数是引用数据类型，此时实参赋值给形参的是实参存储数据的地址值。</code></li></ul></div><h2 id="重载-overload-和重写-override-的区别。重载的方法能否根据返回类型进行区分" tabindex="-1"><a class="header-anchor" href="#重载-overload-和重写-override-的区别。重载的方法能否根据返回类型进行区分"><span>重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。<br> 重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；<br> 重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。<br> 重载对返回类型没有特殊的要求。</p></div><h2 id="抽象类-abstract-class-和接口-interface-有什么异同" tabindex="-1"><a class="header-anchor" href="#抽象类-abstract-class-和接口-interface-有什么异同"><span>抽象类（abstract class）和接口（interface）有什么异同？</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。<br> 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。<br> 接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。 抽象类中的成员可以是 private、默认、protected、public 的，而接口中的成员全都是 public 的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。</p></div><h2 id="抽象的-abstract-方法是否可同时是静态的-static-是否可同时是本地方法-native-是否可同时被-synchronized修饰" tabindex="-1"><a class="header-anchor" href="#抽象的-abstract-方法是否可同时是静态的-static-是否可同时是本地方法-native-是否可同时被-synchronized修饰"><span>抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized修饰？</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>都不能。<br> 抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</p></div><h2 id="静态变量和实例变量的区别" tabindex="-1"><a class="header-anchor" href="#静态变量和实例变量的区别"><span>静态变量和实例变量的区别</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>静态变量是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。<br> 补充：在 Java 开发中，上下文类和工具类中通常会有大量的静态成员。</p></div><h2 id="是否可以从一个静态-static-方法内部发出对非静态-non-static-方法的调用" tabindex="-1"><a class="header-anchor" href="#是否可以从一个静态-static-方法内部发出对非静态-non-static-方法的调用"><span>是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。</p></div><h2 id="如何实现对象克隆" tabindex="-1"><a class="header-anchor" href="#如何实现对象克隆"><span>如何实现对象克隆？</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><ul><li>实现 Cloneable 接口并重写 Object 类中的 clone()方法。</li><li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</li></ul></div><h2 id="接口是否可继承-extends-接口-抽象类是否可实现-implements-接口-抽象类是否可继承具体类-concreteclass" tabindex="-1"><a class="header-anchor" href="#接口是否可继承-extends-接口-抽象类是否可实现-implements-接口-抽象类是否可继承具体类-concreteclass"><span>接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concreteclass）？</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><p>接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。</p></div><h2 id="阐述-final、finally、finalize-的区别" tabindex="-1"><a class="header-anchor" href="#阐述-final、finally、finalize-的区别"><span>阐述 final、finally、finalize 的区别</span></a></h2><div class="hint-container tip"><p class="hint-container-title">提示</p><ul><li>final：修饰符（关键字）有三种用法：如果一个类被声明为 final，意味着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。将变量声明为 final，可以保证它们在使用中不被改变，被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为 final 的方法也同样只能使用，不能在子类中被重写。</li><li>finally：通常放在 try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以将释放外部资源的代码写在 finally 块中。</li><li>finalize：Object 类中定义的方法，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize()方法可以整理系统资源或者执行其他清理工作。</li></ul></div><h2 id="为什么匿名内部类和局部内部类只能访问局部final变量" tabindex="-1"><a class="header-anchor" href="#为什么匿名内部类和局部内部类只能访问局部final变量"><span>为什么匿名内部类和局部内部类只能访问局部final变量？</span></a></h2><p><strong>首先内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。</strong><br> 当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有没有人再引用它时，才会死亡)。<br> 这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。<br> 为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的&quot;copy&quot;。这样就好像延长了局部变量的生命周期。</p>`,33))])}const B=e(r,[["render",g],["__file","base.html.vue"]]),v=JSON.parse('{"path":"/Java/base/base.html","title":"Java基础","lang":"zh-CN","frontmatter":{"title":"Java基础","icon":"java","category":"JavaSE","tag":["Java"]},"headers":[{"level":2,"title":"数据类型","slug":"数据类型","link":"#数据类型","children":[]},{"level":2,"title":"面向对象","slug":"面向对象","link":"#面向对象","children":[]},{"level":2,"title":"接口和抽象类","slug":"接口和抽象类","link":"#接口和抽象类","children":[]},{"level":2,"title":"谈谈你对Java的理解","slug":"谈谈你对java的理解","link":"#谈谈你对java的理解","children":[]},{"level":2,"title":"== 和 equals的区别","slug":"和-equals的区别","link":"#和-equals的区别","children":[]},{"level":2,"title":"a = a + b 与 a += b 的区别","slug":"a-a-b-与-a-b-的区别","link":"#a-a-b-与-a-b-的区别","children":[]},{"level":2,"title":"自增变量面试题解析","slug":"自增变量面试题解析","link":"#自增变量面试题解析","children":[]},{"level":2,"title":"当一个对象被当做参数传递给一个方法，此方法可以改变这个对象的属性，并返回变化后的结果，那么这里到底是值传递还是引用传递？","slug":"当一个对象被当做参数传递给一个方法-此方法可以改变这个对象的属性-并返回变化后的结果-那么这里到底是值传递还是引用传递","link":"#当一个对象被当做参数传递给一个方法-此方法可以改变这个对象的属性-并返回变化后的结果-那么这里到底是值传递还是引用传递","children":[]},{"level":2,"title":"值传递和引用传递面试题","slug":"值传递和引用传递面试题","link":"#值传递和引用传递面试题","children":[]},{"level":2,"title":"重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？","slug":"重载-overload-和重写-override-的区别。重载的方法能否根据返回类型进行区分","link":"#重载-overload-和重写-override-的区别。重载的方法能否根据返回类型进行区分","children":[]},{"level":2,"title":"抽象类（abstract class）和接口（interface）有什么异同？","slug":"抽象类-abstract-class-和接口-interface-有什么异同","link":"#抽象类-abstract-class-和接口-interface-有什么异同","children":[]},{"level":2,"title":"抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized修饰？","slug":"抽象的-abstract-方法是否可同时是静态的-static-是否可同时是本地方法-native-是否可同时被-synchronized修饰","link":"#抽象的-abstract-方法是否可同时是静态的-static-是否可同时是本地方法-native-是否可同时被-synchronized修饰","children":[]},{"level":2,"title":"静态变量和实例变量的区别","slug":"静态变量和实例变量的区别","link":"#静态变量和实例变量的区别","children":[]},{"level":2,"title":"是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？","slug":"是否可以从一个静态-static-方法内部发出对非静态-non-static-方法的调用","link":"#是否可以从一个静态-static-方法内部发出对非静态-non-static-方法的调用","children":[]},{"level":2,"title":"如何实现对象克隆？","slug":"如何实现对象克隆","link":"#如何实现对象克隆","children":[]},{"level":2,"title":"接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concreteclass）？","slug":"接口是否可继承-extends-接口-抽象类是否可实现-implements-接口-抽象类是否可继承具体类-concreteclass","link":"#接口是否可继承-extends-接口-抽象类是否可实现-implements-接口-抽象类是否可继承具体类-concreteclass","children":[]},{"level":2,"title":"阐述 final、finally、finalize 的区别","slug":"阐述-final、finally、finalize-的区别","link":"#阐述-final、finally、finalize-的区别","children":[]},{"level":2,"title":"为什么匿名内部类和局部内部类只能访问局部final变量？","slug":"为什么匿名内部类和局部内部类只能访问局部final变量","link":"#为什么匿名内部类和局部内部类只能访问局部final变量","children":[]}],"git":{"createdTime":1733323129000,"updatedTime":1733323129000,"contributors":[{"name":"CodingQ92","email":"codingrepo@163.com","commits":1}]},"readingTime":{"minutes":16.11,"words":4834},"filePathRelative":"Java/base/base.md","localizedDate":"2024年12月4日","excerpt":"<h2>数据类型</h2>\\n<table>\\n<thead>\\n<tr>\\n<th>类型</th>\\n<th>字节</th>\\n<th>默认值</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>byte</td>\\n<td>1</td>\\n<td>0</td>\\n</tr>\\n<tr>\\n<td>short</td>\\n<td>2</td>\\n<td>0</td>\\n</tr>\\n<tr>\\n<td>int</td>\\n<td>4</td>\\n<td>0</td>\\n</tr>\\n<tr>\\n<td>long</td>\\n<td>8</td>\\n<td>0L</td>\\n</tr>\\n<tr>\\n<td>float</td>\\n<td>4</td>\\n<td>0.0f</td>\\n</tr>\\n<tr>\\n<td>double</td>\\n<td>8</td>\\n<td>0.0d</td>\\n</tr>\\n<tr>\\n<td>char</td>\\n<td>2</td>\\n<td>\\\\u0000</td>\\n</tr>\\n<tr>\\n<td>boolean</td>\\n<td>1</td>\\n<td>false</td>\\n</tr>\\n</tbody>\\n</table>"}');export{B as comp,v as data};
